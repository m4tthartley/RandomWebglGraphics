



<script>
  
// math
function vec2(x, y) {
  return {x, y}
}
function vec3(x, y, z) {
  return {x, y, z}
}
function vec4(x, y, z, w) {
  return {x, y, z, w}
}

function add(a, b) {
  return {
    x: a.x+b.x,
    y: a.y+b.y,
    z: a.z+b.z,
  }
}
function sub(a, b) {
  return {
    x: a.x-b.x,
    y: a.y-b.y,
    z: a.z-b.z,
  }
}
function mul(a, b) {
  return {
    x: a.x*b.x,
    y: a.y*b.y,
    z: a.z*b.z,
  }
}
function div(a, b) {
  return {
    x: a.x/b.x,
    y: a.y/b.y,
    z: a.z/b.z,
  }
}

function length(v) {
  return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z)
}

function normalize(v) {
  const len = length(v)
  return {
    x: v.x / len,
    y: v.y / len,
    z: v.z / len,
  }
}

function cross(a, b) {
  const result = {
    x: a.y*b.z - a.z*b.y,
    y: a.z*b.x - a.x*b.z,
    z: a.x*b.y - a.y*b.x,
  }
  return normalize(result);
}

function perspective(fov, aspect, near, far) {
  if (near < 0) console.error('perspective: near should be above 0')
  const f = 1.0 / Math.tan((fov/180.0*Math.PI) / 2.0)
  return [
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far + near) / (near - far), -1,
    0, 0, (2.0 * far * near) / (near - far), 0,
  ]
}
function ortho(left, top, right, bottom, n, f) {
  return [
    2 / (right-left), 0, 0, 0,
    0, 2 / (top-bottom), 0, 0,
    0, 0, -2 / (f-n), 0,
    -((right+left) / (right-left)), -((top+bottom) / (top-bottom)), -((f+n) / (f-n)), 1,
  ]
}
function translate(x, y, z) {
  return [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    x, y, z, 1,
  ]
}
function rotatex(rads) {
  const s = Math.sin(rads)
  const c = Math.cos(rads)
  return [
    1, 0,  0, 0,
    0, c, -s, 0,
    0, s, c,  0,
    0, 0, 0,  1,
  ]
}
function rotatey(rads) {
  const s = Math.sin(rads)
  const c = Math.cos(rads)
  return [
    c,  0, s, 0,
    0,  1, 0, 0,
    -s, 0, c, 0,
    0,  0, 0, 1,
  ]
}
function rotatez(rads) {
  const s = Math.sin(rads)
  const c = Math.cos(rads)
  return [
    c, -s, 0, 0,
    s, c,  0, 0,
    0, 0,  1, 0,
    0, 0,  0, 1,
  ]
}

// graphics
let gl
// let _canvas_size
let screenWidth = 800
let screenHeight = 600
let quad
let quadi
let MSAA = false
function gl_init(/*c, w = 0, h = 0*/) {
  // _canvas_size = { x: w, y: h }
  const canvas = document.createElement('canvas')//document.querySelector(c)
  canvas.style.position = 'fixed'
  canvas.style.top = '0'
  canvas.style.left = '0'
  document.body = document.createElement('body')
  document.body.appendChild(canvas)
  gl = canvas.getContext('webgl2', {antialias:MSAA, preserveDrawingBuffer:true})
  gl.getExtension('EXT_color_buffer_float')

  screenWidth = window.innerWidth
  screenHeight = window.innerHeight
  canvas.width = screenWidth
  canvas.height = screenHeight
  window.addEventListener('resize', function() {
    screenWidth = window.innerWidth
    screenHeight = window.innerHeight
    canvas.width = screenWidth
    canvas.height = screenHeight
  })

  gl.clearColor(0.0, 0.0, 0.0, 1.0)
  // gl.clear(gl.COLOR_BUFFER_BIT/*  | gl.DEPTH_BUFFER_BIT */)
  gl.viewport(0, 0, canvas.width, canvas.height)

  quad = create_array_buffer([
    -0.5, -0.5, 0.0,
    0.5, -0.5, 0.0,
    0.5, 0.5, 0.0,
    -0.5, 0.5, 0.0,
  ])
  quadi = create_element_array_buffer([
    0, 1, 2,
    0, 2, 3,
  ])
}

function clear(r, g, b, a, depth = false) {
  gl.clearColor(r, g, b, a)
  let mask = gl.COLOR_BUFFER_BIT
  if (depth) mask |= gl.DEPTH_BUFFER_BIT
  gl.clear(mask)
}

function depth(on) {
  if (on) {
    gl.enable(gl.DEPTH_TEST)
    gl.depthFunc(gl.LEQUAL)
  } else {
    gl.disable(gl.DEPTH_TEST)
  }
}

let _current_shader = 0
function use_shader(shader) {
  _current_shader = shader
  gl.useProgram(shader)
}

function create_shader(vertex_shader, fragment_shader) {
  let vs = gl.createShader(gl.VERTEX_SHADER)
  gl.shaderSource(vs, vertex_shader)
  gl.compileShader(vs)
  let fs = gl.createShader(gl.FRAGMENT_SHADER)
  gl.shaderSource(fs, fragment_shader)
  gl.compileShader(fs)
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(vs))
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(fs))
  let shader = gl.createProgram()
  gl.attachShader(shader, vs)
  gl.attachShader(shader, fs)
  gl.linkProgram(shader)
  if (!gl.getProgramParameter(shader, gl.LINK_STATUS)) console.error('Shader link error')
  use_shader(shader)
  return shader
}

function create_array_buffer(floats) {
  const buf = gl.createBuffer()
  gl.bindBuffer(gl.ARRAY_BUFFER, buf)
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floats), gl.STATIC_DRAW)
  return buf
}

function create_element_array_buffer(indices) {
  const buf = gl.createBuffer()
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf)
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW)
  return buf
}

function vertex_pointer(buf, attrib, components, stride = 0, offset = 0) {
  const a = gl.getAttribLocation(_current_shader, attrib)
  gl.enableVertexAttribArray(a)
  gl.bindBuffer(gl.ARRAY_BUFFER, buf)
  gl.vertexAttribPointer(a, components, gl.FLOAT, false, stride, offset)
}

function uniform(uniform, x, y, z, w) {
  switch (arguments.length) {
    case 2:
      gl.uniform1f(gl.getUniformLocation(_current_shader, uniform), x)
      break
    case 3:
      gl.uniform2f(gl.getUniformLocation(_current_shader, uniform), x, y)
      break
    case 4:
      gl.uniform3f(gl.getUniformLocation(_current_shader, uniform), x, y, z)
      break
    case 5:
      gl.uniform4f(gl.getUniformLocation(_current_shader, uniform), x, y, z, w)
      break
    default:
      console.error('Wrong number of parameters')
      break
  }
}

function uniform_matrix(uniform, mat) {
  gl.uniformMatrix4fv(gl.getUniformLocation(_current_shader, uniform), false, new Float32Array(mat))
}

function draw_call(vertex_count) {
  gl.drawArrays(gl.TRIANGLES, 0, vertex_count)
}

function draw_call_lines(vertex_count) {
  gl.drawArrays(gl.LINES, 0, vertex_count)
}

function indexed_draw_call(buf, index_count) {
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buf)
  gl.drawElements(gl.TRIANGLES, index_count, gl.UNSIGNED_SHORT, 0)
}

// Test
// gl_init('canvas', 800, 600)
// const shader = create_shader(`
//  attribute vec3 pos;
//  void main() {
//    gl_Position = vec4(pos, 1.0);
//  }
// `, `
//  void main() {
//    gl_FragColor = vec4(1, 0, 0, 1);
//  }
// `
// )

// const quad = create_array_buffer([
//  -0.5, -0.5,
//  0.5, -0.5,
//  0.5, 0.5,
  
//  -0.5, -0.5,
//  0.5, 0.5,
//  -0.5, 0.5,
// ])
// const quad2 = create_array_buffer([
//  -0.5, -0.5,
//  0.5, -0.5,
//  0.5, 0.5,
//  -0.5, 0.5,
// ])
// const quadi = create_element_array_buffer([
//  0, 1, 2,
//  0, 2, 3,
// ])

// function draw() {
//  gl.clearColor(0, 0, 0, 1)
//  gl.clear(gl.COLOR_BUFFER_BIT)
//  gl.viewport(0, 0, 800, 600)
  
//  vertex_pointer(quad2, 'pos', 2)
//  // draw_call(6)
//  indexed_draw_call(quadi, 6)
  
//  window.requestAnimationFrame(draw)
// }
// draw()

function createFramebuffer(width, height) {
  const result = {
    width,
    height
  }
  result.texture = gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D, result.texture)
  result.buffer = gl.createFramebuffer()
  gl.bindFramebuffer(gl.FRAMEBUFFER, result.buffer)

  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, null)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, result.texture, 0)
  return result
}
function bindRenderTarget(fb) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb ? fb.buffer : null)
  if (fb) {
    gl.viewport(0, 0, fb.width, fb.height)
  } else {
    gl.viewport(0, 0, screenWidth, screenHeight)
  }
}
function uniformRenderTarget(name, fb) {
  gl.bindTexture(gl.TEXTURE_2D, fb ? fb.texture : null)
  if (fb) {
    gl.uniform1i(gl.getUniformLocation(_current_shader, name), fb.texture)
  }
}

function renderQuad() {
  vertex_pointer(quad, 'pos', 3)
  indexed_draw_call(quadi, 6)
}

function renderLine(a, b) {

}
</script>
<script>

  MSAA = false
  gl_init()
  gl.lineWidth(5.0)

  const shader = create_shader(`#version 300 es
    
uniform sampler2D tex;
uniform float aspect;
uniform mat4 camera;
uniform mat4 rotatey;
uniform mat4 rotatex;
layout(location = 0) in vec3 pos;
out vec2 uv;
out vec2 uvsq;
out vec3 fragPos;

void main() {
  vec4 p = vec4(pos, 1.0);
  fragPos = pos;
  gl_Position = camera * (rotatey * p);
  uv = p.xy * vec2(aspect, 1.0);
  uvsq  = pos.xy;
}
  `,`#version 300 es
    
precision mediump float;
uniform sampler2D tex;
uniform float t;
in vec2 uv;
in vec2 uvsq;
in vec3 fragPos;
out vec4 frag;





float hash(float n) {
  return fract(sin(n)*753.5453123);
}

float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);

    float n = p.x + p.y*157.0 + 113.0*p.z;
    return mix(mix(mix(hash(n+0.0), hash(n+1.0), f.x), mix(hash(n+157.0), hash(n+158.0), f.x), f.y),
               mix(mix(hash(n+113.0), hash(n+114.0), f.x), mix(hash(n+270.0), hash(n+271.0), f.x), f.y), f.z);
}

float fbm(vec3 x) {
    float a = noise(x);
    a += noise(x * 2.0) / 2.0;
    a += noise(x * 4.0) / 4.0;
    a += noise(x * 8.0) / 8.0;
    a += noise(x * 16.0) / 16.0;
    return a;
}

float random (vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
}

vec2 random2( vec2 p ) {
  return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}

// float clamp(float a) {
//   return max(min(a, 0.0), 0.0);
// }

vec3 equirect(sampler2D tex, vec3 n) {
  vec3 v = n;
  vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
  uv *= vec2(0.1591, 0.3183);
  uv += 0.5;
  uv.y *= -1.0;
  return texture(tex, uv).rgb;
}

void main() {
  vec3 red = vec3(247.0/255.0, 33.0/255.0 * fragPos.z, 55.0/255.0);
  float fade = 1.0 - smoothstep(2.0, 3.5, -fragPos.z);
  frag = vec4(red * fade, 1);
}
  `)
  const blurShader = create_shader(`#version 300 es
    
uniform sampler2D tex;
uniform float aspect;
uniform mat4 camera;
uniform mat4 rotatey;
layout(location = 0) in vec3 pos;
out vec2 uv;
out vec2 uvsq;

void main() {
  vec4 p = vec4(pos*2.0, 1.0);
  gl_Position = p;
  uv = p.xy * vec2(aspect, 1.0);
  uvsq  = pos.xy+0.5;
}
  `,`#version 300 es
    
precision mediump float;
uniform sampler2D tex;
uniform float t;
uniform vec2 res;
in vec2 uv;
in vec2 uvsq;
out vec4 frag;





float hash(float n) {
  return fract(sin(n)*753.5453123);
}

float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);

    float n = p.x + p.y*157.0 + 113.0*p.z;
    return mix(mix(mix(hash(n+0.0), hash(n+1.0), f.x), mix(hash(n+157.0), hash(n+158.0), f.x), f.y),
               mix(mix(hash(n+113.0), hash(n+114.0), f.x), mix(hash(n+270.0), hash(n+271.0), f.x), f.y), f.z);
}

float fbm(vec3 x) {
    float a = noise(x);
    a += noise(x * 2.0) / 2.0;
    a += noise(x * 4.0) / 4.0;
    a += noise(x * 8.0) / 8.0;
    a += noise(x * 16.0) / 16.0;
    return a;
}

float random (vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
}

vec2 random2( vec2 p ) {
  return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}

// float clamp(float a) {
//   return max(min(a, 0.0), 0.0);
// }

vec3 equirect(sampler2D tex, vec3 n) {
  vec3 v = n;
  vec2 uv = vec2(atan(v.z, v.x), asin(v.y));
  uv *= vec2(0.1591, 0.3183);
  uv += 0.5;
  uv.y *= -1.0;
  return texture(tex, uv).rgb;
}

void main() {
  vec4 color = vec4(0);
  int samples = 0;
  for (float y = -1.0; y < 2.0; y++) {
    for (float x = -1.0; x < 2.0; x++) {
        color += texture(tex, uvsq + vec2(float(x)*(1.0/res.x), float(y)*(1.0/res.y)));
        samples++;
    }
  }
  frag = color / float(samples) * 2.0;
}
  `)

  const fb = createFramebuffer(screenWidth, screenHeight)

  const lines = []

  const linez = -2.0

  for (let i = 0; i < 20; i++) {
    const p1 = vec3(-10.0, -3.0 + i*0.3, linez - i*0.3)
    const p2 = vec3(-1.5, 2.5 + i*0.2, linez - i*0.2)
    const p3 = vec3(0.5, 0.0 + i*0.1, linez - i*0.1)
    const p4 = vec3(3.0, 2.5, linez - i*0.1)

    lines.push(create_array_buffer([
      p2.x, p2.y, p2.z,
      p3.x, p3.y, p3.z
    ]))
    lines.push(create_array_buffer([
      p2.x, p2.y, p2.z,
      p1.x, p1.y, p1.z
    ]))
    lines.push(create_array_buffer([
      p3.x, p3.y, p3.z,
      p4.x, p4.y, p4.z
    ]))
  }

  for (let i = 0; i < 20; i++) {
    const p1 = vec3(-9.0 + i*0.2, -6.0 - i*0.15, linez - i*0.15)
    const p2 = vec3(-0.5 - i*0.04, -0.5 - i*0.1, linez - i*0.1)
    const p3 = vec3(1.5 - i*0.02, -3.0 - i*0.05, linez - i*0.05)
    const p4 = vec3(6.0, 1.0, linez - i*0.05)

    lines.push(create_array_buffer([
      p2.x, p2.y, p2.z,
      p3.x, p3.y, p3.z
    ]))
    lines.push(create_array_buffer([
      p2.x, p2.y, p2.z,
      p1.x, p1.y, p1.z
    ]))
    lines.push(create_array_buffer([
      p3.x, p3.y, p3.z,
      p4.x, p4.y, p4.z
    ]))
  }

  // linei = create_element_array_buffer([
  //   0, 1, 2,
  //   0, 2, 3,
  // ])

  let pan = vec2(0, 0)
  let mouse = vec2(0, 0)
  document.addEventListener('mousemove', e => {
    // console.log(e.clientX, e.clientY)
    mouse = vec2(e.clientX/window.innerWidth*2.0 - 1.0, e.clientY/window.innerHeight*2.0 - 1.0)
    console.log(mouse)
  })

  let rot = 0.0
  let time = 0.0
  function draw(t) {
    if (t) time += t

    rot += 0.02

    pan.x += (mouse.x - pan.x) * 0.03
    pan.y += (mouse.y - pan.y) * 0.03

    // bindRenderTarget(stars)
    // use_shader(starShader)
    // clear(0, 0, 0, 1)
    // uniform('t', t/1000.0)
    // uniform('aspect', screenWidth/screenHeight)
    // renderQuad()

    bindRenderTarget(null)
    use_shader(shader)
    clear(0, 0, 0, 1)
    uniform_matrix('camera', perspective(90, screenWidth/screenHeight, 0.01, 100))
    // uniform_matrix('rotatey', rotatey(Math.sin(rot)*0.2))
    // uniform_matrix('rotatex', rotatex(Math.cos(rot)*0.2))
    // uniform_matrix('rotatey', translate((Math.sin(rot)-0.5)*0.5, (Math.cos(rot)-0.5)*0.5, 0.0))
    uniform_matrix('rotatey', translate(pan.x * -1 * 0.7, pan.y * 0.7, 0.0))
    uniform('t', t/1000.0)
    uniform('aspect', screenWidth/screenHeight)
    lines.forEach(v => {
      vertex_pointer(v, 'pos', 3)
      draw_call_lines(2)
    })


    // bindRenderTarget(null)
    // use_shader(blurShader)
    // uniform('aspect', screenWidth/screenHeight)
    // uniformRenderTarget('tex', fb)
    // uniform('res', screenWidth, screenHeight)
    // renderQuad()

    
    window.requestAnimationFrame(draw)
  }
  draw()

</script>
